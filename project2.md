# 기본적인 디자인

- 쓰레드도 프로세스의 일환으로 보아 ptable.proc에 저장되며, 고유의 pid와 tid를 가진다.

## proc 구조체

![_2021-05-26__4.01.43](uploads/077b375bc89f8b85e5c730dfb656fcc3/_2021-05-26__4.01.43.png)

- 쓰레드를 생성한 프로세스 (마스터 쓰레드) 에서는 생성한 쓰레드들을 관리할 포인터 배열 `struct proc *threads[]` 와 각 쓰레드가 반환한 값을 저장할 배열 `void *t_retval[]` 을 관리한다.
    - 각 배열의 0번째에는 마스터 쓰레드 자신이 저장되어 있다.
- `t_cnt` 에는 프로세스가 가지고 있는 쓰레드의 개수를 저장하고, `t_lastsched` 변수에는 LWP 그룹에서 마지막으로 실행된 쓰레드의 id를 저장해서 그룹 내에서 Round Robin을 구현하는데 사용한다.
- 쓰레드들이 페이지를 id 순서대로 할당하고 해제한다는 보장이 없기 때문에  `freeupages` 배열에 할당해주기 위한 free page의 주소를 저장하고 관리한다.
- 워커 쓰레드들은 쓰레드임을 나타내기 위한 `isthread` 변수와 쓰레드의 id를 저장하는 `tid` 변수를 가지고 마스터 쓰레드를 가리키는 포인터 변수 `master` 를 가진다.
    - 마스터 쓰레드도 워커 쓰레드가 생성되었을 때 자신의 `isthread` 값을 1로 설정해주어 LWP 그룹을 가지고 있는지 확인할 수 있도록 한다.

## 스케줄러와 LWP

- 워커 쓰레드들의 경우 ptable.proc에는 있지만 mlfq or stride 스케줄러에 들어가지 않고 직접 스케줄링 되지 않는다.
    - 예외가 있다면 마스터 쓰레드의 상태가 SLEEPING이고 그 아래 실행가능한 쓰레드가 존재한다면 스케줄러에서 바로 해당 쓰레드로 스케줄링 할 수 있다 (해당 그룹으로)
- 마스터 쓰레드가 스케줄러에서 스케줄링 되면 1tick마다 round robin정책으로 그룹 내에서 LWP 끼리 스케줄러를 거치지 않고 context switching을 진행한다.
- LWP간 스위칭을 위한 round robin은 다음에 실행할 쓰레드를 정하는 함수를 따로 만들고, sched() 함수 내에서 스케줄러로 스위치할지 쓰레드로 스위치할지를 결정한다.

# 세부 구현

## thread.c

- thread.c 파일에는 쓰레드 시스템콜을 비롯한 쓰레드 관련 함수들이 구현되어 있다.

### `struct proc* allocthread (struct proc *master)`

- 프로세스를 할당하는 allocproc 함수와 유사하며 쓰레드 하나를 할당하고 ptable.proc에 저장한다.
- 쓰레드의 커널스택을 할당하고 마스터 쓰레드의 trapframe을 복사해올 공간을 만든다.
- 마스터 쓰레드의 쓰레드 배열에 남는 자리를 찾고 매핑해준다.
- 할당한 쓰레드를 리턴해준다.

### `int t_allocustack (struct proc *master, struct proc *thread)`

- `allocuvm()` 함수를 호출해서 쓰레드에게 유저스택을 위한 페이지 두개를 할당해준다.
- 마스터 쓰레드의 freeupage에 남는 자리가 있다면 ( free한 주소값이 배열에 저장되어 있다면 ) 해당 주소에서부터 페이지 두개를 할당해준다.
- 남는 자리가 없다면 마스터의 sz 부터 페이지를 할당해준다.

### `int t_deallocustack (struct proc *thread)`

- `kfree()` 함수를 호출해서 쓰레드에게 할당해준 커널스택 영역을 해제 한다.
- `deallocuvm()` 함수를 호출해서 쓰레드에게 할당해준 페이지를 해제한다.
- 마스터 쓰레드의 freeupage에 값을 저장할 수 있다면 free한 주소값을 저장해둔다.

### `int thread_create(thread_t *thread, void *(*start_routine)(void *), void *arg)`

- 쓰레드를 생성하는 함수
- `allocthread` 함수를 호출해서 커널 스택을 할당하고, `t_allocustack` 함수를 호출해서 유저 스택을 위한 페이지를 할당한다.
- 매개변수로 받은 thread가 가리키는 곳에 할당한 쓰레드의 id를 저장한다.
- 매개변수 arg를 유저스택에 넣어주고 마스터 쓰레드의 trapframe을 복사해주고 유저스택의 eip를 start_routine으로 변경해서 시작지점을 설정해준다.
- 쓰레드 생성에 성공했다면 0을 반환한다.

### `int thread_join(thread_t thread, void **ret_val)`

- 지정한 쓰레드가 종료될 때까지 기다리고 자원을 회수하는 함수
- 워커 쓰레드가 종료되지 않았으면 ( ZOMBIE 가 아니면 ) sleep을 호출하고 잠에 든다.
- 워커 쓰레드가 깨워주면 `t_deallocuvm` 함수를 호출해서 해당 워커 쓰레드에 할당해준 페이지를 회수한다.
- 해당 쓰레드가 종료되고 반환한 값은 마스터 쓰레드의 `t_retval[tid]` 에 저장되어 있고 해당 값을  `ret_val` 에 넘겨준다.
- 성공적으로 실행되면 0을 반환한다.

### `void thread_exit(void *ret_val)`

- 함수를 호출한 쓰레드를  종료하고, 반환 값을 ret_val에 저장해준다.
- 마스터 쓰레드를 깨우고 상태를 ZOMBIE로 변경 후 `sched()` 함수를 호출한다.

### `struct proc* get_next_thread (struct proc *master)`

- LWP 그룹 내에서 Round Robin 을 구현할 때 다음에 실행될 쓰레드를 찾는다.
- 마지막으로 실행된 쓰레드 다음부터 RUNNABLE한 쓰레드를 찾고 해당 쓰레드를 반환한다.
- 만약 그룹 내에 실행할 수 있는 쓰레드가 없다면 0을 반환한다.

### `void run_next_thread()`

- LWP 그룹 내에서 다음 쓰레드로 문맥 전환을 한다.
- `get_next_thread()` 함수를 호출해서 다음에 실행할 쓰레드를 찾는다.
- 만약 `next` 값이 0이라서 그룹 내에 실행할 쓰레드가 없다면 스케줄러로 문맥 전환한다.
- 다음에 실행할 쓰레드가 있다면 cpu 구조체의 `proc` 에 해당 쓰레드를 저장하고 gdt와 tss 레지스터 값을 변경해준다.
- `next thread` 의 상태를 RUNNING으로 변경하고 문맥 전환한다.

## trap.c

- timer interrupt가 발생했을 때 `check_on_timer()` 함수를 호출해서 해당 프로세스가 속한 그룹이 정해진 시간을 다 썼는가를 확인한다.
    - 다썼다면 마스터 쓰레드의 `isexhausted` 값이 1이고 아직 cpu를 더 쓸 수 있다면 0이 저장되어 있다.
- 만약 현재 실행 중인게 쓰레드이거나 그룹을 가진 프로세스라면 매 1tick 마다 다음 쓰레드를 실행해야하므로 `yield` 를 호출한다.
- 쓰레드가 아니더라도 시간을 다 썼다면 `yield` 를 호출한다.

## sched 함수

- 스케줄러로 문맥 전환을 시도하는 sched 함수 내에서 경우의 수에 따라 스케줄러 혹은 그룹 내의 다음 쓰레드로 문맥 전환을 시도한다.
- 현재 실행 중인게 프로세스이든 쓰레드이든 시간을 다 썼다면 스케줄러로 문맥 전환한다.
- 시간을 다 안썼고, LWP 그룹이라면 `run_next_thread` 함수를 호출해서 그룹내의 다른 쓰레드로 문맥 전환한다.
- 그 외의 경우 ( 그냥 yield를 호출해서 온 경우 ) 에는 스케줄러로 문맥 전환한다.

## Interaction with schedulers

- 마스터 쓰레드가 join을 호출하고 sleep하는 상황을 해결하기 위해 기존 스케줄러를 변경했다.
    - mlfq scheduler

    ![_2021-05-26__5.44.18](uploads/0a60df4943d3fe7025c32d0d6cca2233/_2021-05-26__5.44.18.png)

    - stride scheduler

    ![_2021-05-26__5.44.33](uploads/d3f00a805dc08d9e00b62122a0235453/_2021-05-26__5.44.33.png)

    - 워커 쓰레드들이 실행되기 위해서는 먼저 마스터 쓰레드가 스케줄러에서 선택 되어야하는데 마스터 쓰레드가 sleep 상태면 워커 쓰레드들까지 선택되지 못하는 문제가 발생한다.
    - 따라서 스케줄러 내애서 선택된 프로세스가 SLEEPING 상태이지만 LWP 그룹이 있다면 (p→isthread) `get_next_thread` 함수를 호출해서 그룹 내에서 실행 가능한 쓰레드를 찾는다.
    - 실행 가능한 쓰레드가 있다면 해당 쓰레드로 문맥 전환을 한다.
